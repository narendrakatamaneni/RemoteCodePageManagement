<DOCTYPE !HTML>
<html>
  <head>
    <Title>Comm.cpp</Title>
    <style>
      body {
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }
      </style>
  <link rel = "stylesheet" type = "text/css" href = "style.css" >
  <script src="script.js"> </script> 
  </head>

  <body>
 <input type ="submit" value= "Comments" id ="cmt" onclick="togglevisibility('comments')" ></input>
 <input type ="submit" value= "Class"  id ="cls" onclick="togglevisibility('clsClass')" ></input>
 <input type ="submit" value= "Function" id ="fun" onclick="togglevisibility('funClass')" ></input>
    <h3>Dependencies: 
      <a href="Comm.h.html">Comm.h</a><br/>
      <a href="Logger.h.html">Logger.h</a><br/>
      <a href="Utilities.h.html">Utilities.h</a><br/>
      <a href="Cpp11-BlockingQueue.h.html">Cpp11-BlockingQueue.h</a><br/>
    </h3>    <pre>
<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">// Comm.h - message-passing communication facility                 //</span>
<span class="comments">// ver 2.2                                                         //</span>
<span class="comments">// Jim Fawcett, CSE687-OnLine Object Oriented Design, Fall 2017    //</span>
<span class="comments">/////////////////////////////////////////////////////////////////////</span>

#include "Comm.h"
#include "../Logger/Logger.h"
#include "../Utilities/Utilities.h"
#include "../Cpp11-BlockingQueue/Cpp11-BlockingQueue.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;conio.h&gt;

using namespace MsgPassingCommunication;
using namespace Sockets;
using SUtils = Utilities::StringHelper;

const std::string saveFilePath = "../SaveFiles";
const std::string sendFilePath = "../SendFiles";
const size_t BlockSize = 1024;
Socket::byte rwBuffer[BlockSize];

<span class="comments">//----&lt; constructor sets port &gt;--------------------------------------</span>

Receiver::Receiver(EndPoint ep, const std::string& name) : listener(ep.port), rcvrName(name)
<span class="funClass">{
  StaticLogger&lt;1&gt;::write("\n  -- starting Receiver");
}</span>
<span class="comments">//----&lt; returns reference to receive queue &gt;-------------------------</span>

BlockingQueue&lt;Message&gt;* Receiver::queue()
<span class="funClass">{
  return &rcvQ;
}</span>
<span class="comments">//----&lt; starts listener thread running callable object &gt;-------------</span>

template&lt;typename CallableObject&gt;
void Receiver::start(CallableObject& co)
<span class="funClass">{
  listener.start(co);
}</span>
<span class="comments">//----&lt; stops listener thread &gt;--------------------------------------</span>

void Receiver::stop()
<span class="funClass">{
  listener.stop();
}</span>
<span class="comments">//----&lt; retrieves received message &gt;---------------------------------</span>

Message Receiver::getMessage()
<span class="funClass">{
  StaticLogger&lt;1&gt;::write("\n  -- " + rcvrName + " deQing message");
  return rcvQ.deQ();
}</span>
<span class="comments">//----&lt; constructor initializes endpoint object &gt;--------------------</span>

Sender::Sender(const std::string& name) : sndrName(name)
<span class="funClass">{
  lastEP = EndPoint();  <span class="comments">// used to detect change in destination</span>
}</span>
<span class="comments">//----&lt; destructor waits for send thread to terminate &gt;--------------</span>

Sender::~Sender()
<span class="funClass">{
  if (sendThread.joinable())
    sendThread.join();
}</span>
<span class="comments">//----&lt; starts send thread deQ, inspect, and send loop &gt;-------------</span>

void Sender::start()
<span class="funClass">{
  std::function &lt;void()&gt; threadProc = [&]() {
    while (true)
    {
      Message msg = sndQ.deQ();
      if (msg.containsKey("verbose"))
      {
        <span class="comments">//::Beep(1000, 100);</span>
        <span class="comments">//::Beep(1000, 100);</span>
        <span class="comments">//::Beep(1000, 100);</span>
      }
      if (msg.command() == "quit")
      {
        StaticLogger&lt;1&gt;::write("\n  -- send thread shutting down");
        return;
      }
      StaticLogger&lt;1&gt;::write("\n  -- " + sndrName + " send thread sending " + msg.name());
      std::string msgStr = msg.toString();

      if (msg.to().address != lastEP.address || msg.to().port != lastEP.port)
      {
        connecter.shutDown();
        <span class="comments">//connecter.close();</span>
        StaticLogger&lt;1&gt;::write("\n  -- attempting to connect to new endpoint: " + msg.to().toString());
        if (!connect(msg.to()))
        {
          StaticLogger&lt;1&gt;::write("\n can't connect");
          continue;
        }
        else
        {
          StaticLogger&lt;1&gt;::write("\n  connected to " + msg.to().toString());
        }
      }
      if (msg.containsKey("file"))
      {
        sendFile(msg);
      }
      else
      {
        bool sendRslt = connecter.send(msgStr.length(), (Socket::byte*)msgStr.c_str());
      }
    }
  };
  std::thread t(threadProc);
  sendThread = std::move(t);
}</span>
<span class="comments">//----&lt; stops send thread by posting quit message &gt;------------------</span>

void Sender::stop()
<span class="funClass">{
  Message msg;
  msg.name("quit");
  msg.command("quit");
  postMessage(msg);
  connecter.shutDown();
}</span>
<span class="comments">//----&lt; attempts to connect to endpoint ep &gt;-------------------------</span>

bool Sender::connect(EndPoint ep)
<span class="funClass">{
  lastEP = ep;
  return connecter.connect(ep.address, ep.port);
}</span>
<span class="comments">//----&lt; posts message to send queue &gt;--------------------------------</span>

void Sender::postMessage(Message msg)
<span class="funClass">{
  sndQ.enQ(msg);
}</span>
<span class="comments">//----&lt; sends binary file &gt;------------------------------------------</span>
<span class="comments">/*
*  - not implemented yet
*/</span>
bool Sender::sendFile(Message msg)
<span class="funClass">{
  if (!msg.containsKey("file"))
    return false;
  std::string fileSpec = sendFilePath + "/" + msg.file();
  std::ifstream sendFile(fileSpec, std::ios::binary);
  if (!sendFile.good())
    return false;
  while (true)
  {
    sendFile.read(rwBuffer, BlockSize);
    size_t blockSize = (size_t)sendFile.gcount();
    msg.contentLength(blockSize);
    std::string msgString = msg.toString();
    connecter.sendString(msgString);
    if (blockSize == 0)
      break;
    connecter.send(blockSize, rwBuffer);
  }
  sendFile.close();
  return true;
}</span>
<span class="comments">//----&lt; callable object posts incoming message to rcvQ &gt;-------------</span>
<span class="comments">/*
*  This is ClientHandler for receiving messages and posting
*  to the receive queue.
*/</span>
class ClientHandler
<span class="clsClass">{
public:
  <span class="comments">//----&lt; acquire reference to shared rcvQ &gt;-------------------------</span>

  ClientHandler(BlockingQueue&lt;Message&gt;* pQ, const std::string& name = "clientHandler") : pQ_(pQ), clientHandlerName(name)
  <span class="funClass">{
    StaticLogger&lt;1&gt;::write("\n  -- starting ClientHandler");
  }</span>
  <span class="comments">//----&lt; shutdown message &gt;-----------------------------------------</span>

  ~ClientHandler() 
  <span class="funClass">{ 
    StaticLogger&lt;1&gt;::write("\n  -- ClientHandler destroyed;"); 
  }</span>
  <span class="comments">//----&lt; set BlockingQueue &gt;----------------------------------------</span>

  void setQueue(BlockingQueue&lt;Message&gt;* pQ)
  <span class="funClass">{
    pQ_ = pQ;
  }</span>
  <span class="comments">//----&lt; frame message string by reading bytes from socket &gt;--------</span>

  std::string readMsg(Socket& socket)
  <span class="funClass">{
    std::string temp, msgString;
    while (socket.validState())
    {
      temp = socket.recvString('\n');  <span class="comments">// read attribute</span>
      msgString += temp;
      if (temp.length() &lt; 2)           <span class="comments">// if empty line we are done</span>
        break;
    }
    return msgString;
  }</span>
  <span class="comments">//----&lt; receive file blocks &gt;--------------------------------------</span>
  <span class="comments">/*
  *  - expects msg to contain file and contentLength attributes
  *  - expects to be connected to appropriate destination
  *  - these requirements are established in Sender::start()
  */</span>
  bool receiveFile(Message msg)
  <span class="funClass">{
    std::string fileName = msg.file();
    std::string fileSpec = saveFilePath + "/" + fileName;
    std::ofstream saveStream(fileSpec, std::ios::binary);
    if (!saveStream.good())
    {
      return false;
    }
    while (true)
    {
      size_t blockSize = msg.contentLength();
      if (blockSize == 0)
        break;
      Socket::byte terminator;
      pSocket-&gt;recv(1, &terminator);
      pSocket-&gt;recv(blockSize, rwBuffer);
      saveStream.write(rwBuffer, blockSize);
      std::string msgString = readMsg(*pSocket);
      if (msgString.length() == 0)
      {
        break;
      }
      msg = Message::fromString(msgString);
      if (msg.contentLength() == 0)
        break;
    }
    saveStream.flush();
    saveStream.close();
    pQ_-&gt;enQ(msg);
    return true;
  }</span>
  <span class="comments">//----&lt; reads messages from socket and enQs in rcvQ &gt;--------------</span>

  void operator()(Socket socket)
  <span class="funClass">{
    pSocket = &socket;
    while (socket.validState())
    {
      std::string msgString = readMsg(socket);
      if (msgString.length() == 0)
      {
        <span class="comments">// invalid message</span>
        break;
      }
      Message msg = Message::fromString(msgString);
      StaticLogger&lt;1&gt;::write("\n  -- " + clientHandlerName + " RecvThread read message: " + msg.name());
      <span class="comments">//std::cout &lt;&lt; "\n  -- " + clientHandlerName + " RecvThread read message: " + msg.name();</span>
      if (msg.containsKey("file"))
      {
        receiveFile(msg);
      }
      pQ_-&gt;enQ(msg);
      <span class="comments">//std::cout &lt;&lt; "\n  -- message enqueued in rcvQ";</span>
      if (msg.command() == "quit")
        break;
    }
    StaticLogger&lt;1&gt;::write("\n  -- terminating ClientHandler thread");
  }</span>
private:
  BlockingQueue&lt;Message&gt;* pQ_;
  std::string clientHandlerName;
  Socket* pSocket = nullptr;
};
</span>
Comm::Comm(EndPoint ep, const std::string& name) : rcvr(ep, name), sndr(name), commName(name) {}</span>

void Comm::start()
<span class="funClass">{
  BlockingQueue&lt;Message&gt;* pQ = rcvr.queue();
  ClientHandler* pCh = new ClientHandler(pQ, commName);
  <span class="comments">/*
    There is a trivial memory leak here.  
    This ClientHandler is a prototype used to make ClientHandler copies for each connection.
    Those are not created on the heap, and are destroyed when the connection closes.
    Only one Client handler prototype is created for each Comm object and will live until
    the end of the program.

    I will clean this up in the next version.
  */</span>
  rcvr.start(*pCh);
  sndr.start();
}</span>

void Comm::stop()
<span class="funClass">{
  rcvr.stop();
  sndr.stop();
}</span>

void Comm::postMessage(Message msg)
<span class="funClass">{
  sndr.postMessage(msg);
}</span>

Message Comm::getMessage()
<span class="funClass">{
  return rcvr.getMessage();
}</span>

std::string Comm::name()
<span class="funClass">{
  return commName;
}</span>

<span class="comments">//----&lt; test stub &gt;--------------------------------------------------</span>

#ifdef TEST_COMM

<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">// Test #1 - Demonstrates Sender and Receiver operations</span>

void DemoSndrRcvr(const std::string& machineName)
<span class="funClass">{
  SUtils::title("Demonstrating Sender and Receiver classes");

  SocketSystem ss;
  EndPoint ep1;
  ep1.port = 9091;
  ep1.address = "localhost";
  Receiver rcvr1(ep1);
  BlockingQueue&lt;Message&gt;* pQ1 = rcvr1.queue();

  ClientHandler ch1(pQ1);
  rcvr1.start(ch1);

  EndPoint ep2;
  ep2.port = 9092;
  ep2.address = "localhost";
  Receiver rcvr2(ep2);
  BlockingQueue&lt;Message&gt;* pQ2 = rcvr2.queue();

  ClientHandler ch2(pQ2);
  rcvr2.start(ch2);

  Sender sndr;
  sndr.start();
  bool connected = sndr.connect(ep1);
  Message msg;
  msg.name("msg #1");
  msg.to(ep1);
  msg.from(msg.to());
  msg.command("do it");
  msg.attribute("bodyAttrib", "zzz");
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  sndr.postMessage(msg);

  msg.name("msg #2");
  msg.to(EndPoint(machineName, 9092));
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  sndr.postMessage(msg);

  Message rcvdMsg = rcvr1.getMessage();  <span class="comments">// blocks until message arrives</span>
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  rcvr1 in main received message: " &lt;&lt; rcvdMsg.name();
  rcvdMsg.show();

  rcvdMsg = rcvr2.getMessage();  <span class="comments">// blocks until message arrives</span>
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  rcvr2 in main received message: " &lt;&lt; rcvdMsg.name();
  rcvdMsg.show();

  SUtils::title("Sending message to EndPoint that doesn't exist");

  msg.name("msg #3");
  msg.to(EndPoint("DoesNotExist", 1111));  <span class="comments">// Unknown endpoint - should fail</span>
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  msg.show();
  sndr.postMessage(msg);                   <span class="comments">// will never reach rcvr</span>

  msg.name("msg #4");
  msg.to(EndPoint("localhost", 9091));
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  sndr.postMessage(msg);                  <span class="comments">// this should succeed</span>
  StaticLogger&lt;1&gt;::flush();
  rcvdMsg = rcvr1.getMessage();
  std::cout &lt;&lt; "\n  rcvr1 in main received message: " &lt;&lt; rcvdMsg.name();
  rcvdMsg.show();

  rcvr1.stop();
  rcvr2.stop();
  sndr.stop();
  StaticLogger&lt;1&gt;::flush();

  std::cout &lt;&lt; "\n  press enter to quit DemoSndrRcvr";
  _getche();
  std::cout &lt;&lt; "\n";
}</span>

<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">// Test #2 - Demonstrates Comm class using a single thread</span>
<span class="comments">//           sending and receiving messages from two Comm</span>
<span class="comments">//           instances.</span>

void DemoCommClass(const std::string& machineName)
<span class="funClass">{
  SUtils::title("Demonstrating Comm class");

  SocketSystem ss;

  EndPoint ep1("localhost", 9191);
  Comm comm1(ep1, "comm1");
  comm1.start();

  EndPoint ep2("localhost", 9192);
  Comm comm2(ep2, "comm2");
  comm2.start();

  <span class="comments">// send msg from comm1 to comm1</span>
  Message msg;
  msg.name("msg #1");
  msg.to(ep1);
  msg.from(ep1);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main posting message:   " &lt;&lt; msg.name();
  comm1.postMessage(msg);
  msg = comm1.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main received message:  " &lt;&lt; msg.name();
  msg.show();

  <span class="comments">// send msg from comm1 to comm2</span>
  msg.name("msg #2");
  msg.from(ep1);
  msg.to(ep2);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main posting message:  " &lt;&lt; msg.name();
  comm1.postMessage(msg);
  msg = comm2.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main received message: " &lt;&lt; msg.name();
  msg.show();

  <span class="comments">// send msg from comm2 to comm1</span>
  msg.name("msg #3");
  msg.to(ep1);
  msg.from(ep2);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main posting message:  " &lt;&lt; msg.name();
  comm2.postMessage(msg);
  msg = comm1.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main received message: " &lt;&lt; msg.name();
  msg.show();

  <span class="comments">// send msg from comm2 to comm2</span>
  msg.name("msg #4");
  msg.from(ep2);
  msg.to(ep2);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main posting message:  " &lt;&lt; msg.name();
  comm2.postMessage(msg);
  msg = comm2.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main received message: " &lt;&lt; msg.name();
  msg.show();

  comm1.stop();
  comm2.stop();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  press enter to quit DemoComm";
  _getche();
}</span>
<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">// Test #3 - Demonstrate server with two concurrent clients</span>
<span class="comments">//           sending and receiving messages</span>

<span class="comments">//----&lt; handler for first concurrent client &gt;------------------------</span>

void ThreadProcClnt1()
<span class="funClass">{
  Comm comm(EndPoint("localhost", 9891), "client1Comm");
  comm.start();
  EndPoint serverEP("localhost", 9890);
  EndPoint clientEP("localhost", 9891);
  size_t IMax = 3;
  for (size_t i = 0; i &lt; IMax; ++i)
  {
    Message msg(serverEP, clientEP);
    msg.name("client #1 : msg #" + Utilities::Converter&lt;size_t&gt;::toString(i));
    std::cout &lt;&lt; "\n  " + comm.name() + " posting:  " &lt;&lt; msg.name();
    comm.postMessage(msg);
    Message rply = comm.getMessage();
    std::cout &lt;&lt; "\n  " + comm.name() + " received: " &lt;&lt; rply.name();
    ::Sleep(100);
  }
  Message fileMsg(serverEP, clientEP);
  fileMsg.name("fileSender");
  fileMsg.file("logger.cpp");
  comm.postMessage(fileMsg);
  ::Sleep(200);

  Message stop;
  stop.name("stop");
  stop.to(serverEP);
  stop.command("stop");
  comm.postMessage(stop);
}</span>
<span class="comments">//----&lt; handler for 2nd concurrent client &gt;--------------------------</span>

void ThreadProcClnt2()
<span class="funClass">{
  Comm comm(EndPoint("localhost", 9892), "client2Comm");
  comm.start();
  EndPoint serverEP("localhost", 9890);
  EndPoint clientEP("localhost", 9892);
  size_t IMax = 3;
  for (size_t i = 0; i &lt; IMax; ++i)
  {
    Message msg(serverEP, clientEP);
    msg.name("client #2 : msg #" + Utilities::Converter&lt;size_t&gt;::toString(i));
    std::cout &lt;&lt; "\n  " + comm.name() + " posting:  " &lt;&lt; msg.name();
    comm.postMessage(msg);
    Message rply = comm.getMessage();
    std::cout &lt;&lt; "\n  " + comm.name() + " received: " &lt;&lt; rply.name();
  }
  Message fileMsg(serverEP, clientEP);
  fileMsg.name("fileSender");
  fileMsg.file("logger.h");
  comm.postMessage(fileMsg);
  ::Sleep(200);
}</span>
<span class="comments">//----&lt; server demonstrates two-way asynchronous communication &gt;-----</span>
<span class="comments">/*
*  - One server receiving messages and sending replies to
*    two concurrent clients.
*/</span>
void DemoClientServer()
<span class="funClass">{
  SUtils::title("Demonstrating Client-Server - one server with two concurrent clients");

  SocketSystem ss;

  EndPoint serverEP("localhost", 9890);
  EndPoint clientEP("localhost", 9891);
  Comm comm(serverEP, "serverComm");
  comm.start();
  std::thread t1(ThreadProcClnt1);
  t1.detach();
  std::thread t2(ThreadProcClnt2);
  t2.detach();

  Message msg, rply;
  rply.name("reply");
  size_t count = 0;
  while (true)
  {
    <span class="comments">// display each incoming message</span>

    msg = comm.getMessage();
    std::cout &lt;&lt; "\n  " + comm.name() + " received message: " &lt;&lt; msg.name();

    if (msg.containsKey("file"))  <span class="comments">// is this a file message?</span>
    {
      if(msg.contentLength() == 0)
        std::cout &lt;&lt; "\n  " + comm.name() + " received file \"" + msg.file() + "\" from " + msg.name();
    }
    else  <span class="comments">// non-file message</span>
    {
      rply.to(msg.from());
      rply.from(serverEP);
      rply.name("server reply #" + Utilities::Converter&lt;size_t&gt;::toString(++count) + " to " + msg.from().toString());

      comm.postMessage(rply);
      if (msg.command() == "stop")
      {
        break;
      }
    }
  }

  comm.stop();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  press enter to quit DemoClientServer";
  _getche();
}</span>

Cosmetic cosmetic;

int main()
<span class="funClass">{
  SUtils::Title("Demo of Message-Passing Communication");
  Utilities::putline();

  StaticLogger&lt;1&gt;::attach(&std::cout);

  <span class="comments">///////////////////////////////////////////////////////////////////</span>
  <span class="comments">// remove comment on line below to show many of the gory details</span>
  <span class="comments">//</span>
  <span class="comments">//StaticLogger&lt;1&gt;::start();</span>

  <span class="comments">///////////////////////////////////////////////////////////////////</span>
  <span class="comments">// if you uncomment the lines below, you will run all demos</span>

  <span class="comments">//DemoSndrRcvr("Odin");  // replace "Odin" with your machine name</span>
  <span class="comments">//DemoCommClass("Odin");</span>
  DemoClientServer();

  return 0;
}</span>
#endif
    </pre>
  </body>
</html>
