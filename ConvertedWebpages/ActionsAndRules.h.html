<DOCTYPE !HTML>
<html>
  <head>
    <Title>ActionsAndRules.h</Title>
    <style>
      body {
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }
      </style>
  <link rel = "stylesheet" type = "text/css" href = "style.css" >
  <script src="script.js"> </script> 
  </head>

  <body>
 <input type ="submit" value= "Comments" id ="cmt" onclick="togglevisibility('comments')" ></input>
 <input type ="submit" value= "Class"  id ="cls" onclick="togglevisibility('clsClass')" ></input>
 <input type ="submit" value= "Function" id ="fun" onclick="togglevisibility('funClass')" ></input>
    <h3>Dependencies: 
      <a href="Parser.h.html">Parser.h</a><br/>
      <a href="GrammarHelpers.h.html">GrammarHelpers.h</a><br/>
      <a href="ITokenCollection.h.html">ITokenCollection.h</a><br/>
      <a href="ScopeStack.h.html">ScopeStack.h</a><br/>
      <a href="Toker.h.html">Toker.h</a><br/>
      <a href="Semi.h.html">Semi.h</a><br/>
      <a href="AbstrSynTree.h.html">AbstrSynTree.h</a><br/>
      <a href="Logger.h.html">Logger.h</a><br/>
      <a href="FileSystem.h.html">FileSystem.h</a><br/>
    </h3>    <pre>
#ifndef ACTIONSANDRULES_H
#define ACTIONSANDRULES_H
<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">//  ActionsAndRules.h - declares new parsing rules and actions     //</span>
<span class="comments">//  ver 1.0                                                        //</span>
<span class="comments">//  Author:        Narendra Katamaneni, Syracuse University		   //</span>
<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">/*
  Module Operations: 
  ==================
  This module defines several action classes.  Its classes provide 
  specialized services needed for specific applications.  The modules
  Parser, Semiression, and Tokenizer, are intended to be reusable
  without change.  This module provides a place to put extensions of
  these facilities and is not expected to be reusable. 

  Required files
  ==============
    - Parser.h, GrammarHelpers.h, ScopeStack.h,
      ITokenCollection.h, Semi.h, Toker.h,FileSystem.h,Logger.h,AbstrSynTree.h

  Maintenance History:
  ====================
  ver 1.0 : 11 Feb 2019
  - small changes spread over many of the Rule and Action classes, caused
    by changing the lexical scanner, which forced some changes to the
    scanner's interface (sigh!)

*/</span>
<span class="comments">//</span>
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "Parser.h"
#include "../GrammarHelpers/GrammarHelpers.h"
#include "../SemiExpression/ITokenCollection.h"
#include "../ScopeStack/ScopeStack.h"
#include "../Tokenizer/Toker.h"
#include "../SemiExpression/Semi.h"
#include "../AbstractSyntaxTree/AbstrSynTree.h"
#include "../Logger/Logger.h"
#include "../FileSystem/FileSystem.h"

namespace CodeAnalysis
{  
  <span class="comments">///////////////////////////////////////////////////////////////////</span>
  <span class="comments">// Repository instance is used to share resources</span>
  <span class="comments">// among all actions.</span>

  enum Language { C <span class="comments">/* not implemented */, Cpp, CSharp };

  class Repository  <span class="comments">// application specific</span>
  <span class="clsClass">{
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;  <span class="comments">// use for application results</span>
    using Demo = Logging::StaticLogger&lt;1&gt;;  <span class="comments">// use for demonstrations of processing</span>
    using Dbug = Logging::StaticLogger&lt;2&gt;;  <span class="comments">// use for debug output</span>
    using Package = std::string;
    using Path = std::string;

  private:
    Language language_ = Language::Cpp;
    Path path_;
    ScopeStack&lt;ASTNode*&gt; stack;
    AbstrSynTree ast;
    ASTNode* pGlobalScope;
    Package package_;
    Lexer::Toker* p_Toker;
    Access currentAccess_ = Access::publ;
    static Repository* instance;
  
  public:
    
    Repository(Lexer::Toker* pToker) : ast(stack)
    <span class="funClass">{
      p_Toker = pToker;
      pGlobalScope = stack.top();  <span class="comments">// installed in AST constructor</span>
      instance = this;
    }</span>

    ~Repository()
    <span class="funClass">{
      <span class="comments">//Dbug::write("\n  deleting repository");</span>
    }</span>

    Language& language() { return language_; }</span>

    Package& package() { return package_; }</span>

    Path& currentPath() { return path_; }</span>

    Access& currentAccess() { return currentAccess_; }</span>

    static Repository* getInstance() { return instance; }</span>

    ScopeStack&lt;ASTNode*&gt;& scopeStack() { return stack; }</span>

    AbstrSynTree& AST() { return ast; }</span>

    ASTNode* getGlobalScope() { return pGlobalScope; }</span>

    Lexer::Toker* Toker() { return p_Toker; }</span>

    size_t lineCount() 
    <span class="funClass">{ 
      return (size_t)(p_Toker-&gt;lineCount()); 
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect beginning of scope</span>

  class BeginScope : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test begin scope", *pTc);

      <span class="comments">// don't parse Semi with single semicolon token</span>

      if (pTc-&gt;size() == 1 && (*pTc)[0] == ";")
        return IRule::Stop;

      if (pTc-&gt;contains("{"))
      {
        doActions(pTc);
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to handle scope stack at beginning of scope</span>

  class HandleBeginScope : public IAction
  <span class="clsClass">{
    Repository* p_Repos;
  public:
    HandleBeginScope(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("handle begin scope", *pTc);

      ASTNode* pElem = new ASTNode;
      pElem-&gt;type_ = "anonymous";
      pElem-&gt;name_ = "none";
      pElem-&gt;package_ = p_Repos-&gt;package();
      pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
      pElem-&gt;endLineCount_ = 1;
      pElem-&gt;path_ = p_Repos-&gt;currentPath();
      <span class="comments">/*
       * make this ASTNode child of ASTNode on stack top
       * then push onto stack
       */</span>
      p_Repos-&gt;AST().add(pElem);
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect end of scope</span>

  class EndScope : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test end scope", *pTc);

      size_t posCloseBrace;
      pTc-&gt;find("}", posCloseBrace);
      if (posCloseBrace &lt; pTc-&gt;size())
      {
        doActions(pTc);
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to handle scope stack at end of scope</span>

  class HandleEndScope : public IAction
  <span class="clsClass">{
    Repository* p_Repos;
  public:
    using Dbug = Logging::StaticLogger&lt;2&gt;;

    HandleEndScope(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle end scope", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pElem = p_Repos-&gt;AST().pop();
      if (pElem == nullptr)
        return;

      pElem-&gt;endLineCount_ = p_Repos-&gt;lineCount();
      if (pElem-&gt;type_ == "class" || pElem-&gt;type_ == "struct")
        (pElem-&gt;endLineCount_)++;

      p_Repos-&gt;currentAccess() = Access::priv;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect access for C++</span>

  class DetectAccessSpecifier : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test access spec", *pTc);

      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      size_t pos;
      pTc-&gt;find(":", pos);
      if (0 &lt; pos && pos &lt; pTc-&gt;size())
      {
        const std::string tok = (*pTc)[pos - 1];
        if (tok == "public" || tok == "protected" || tok == "private")
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to handle access specifier</span>

  class HandleAccessSpecifier : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleAccessSpecifier(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle access spec: ", *pTc);

      std::string tok = (*pTc)[pTc-&gt;size() - 2];
      Access& access = p_Repos-&gt;currentAccess();
      if (tok == "public")
        access = Access::publ;
      else if (tok == "protected")
        access = Access::prot;
      else
        access = Access::priv;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect preprocessor statements</span>

  class PreprocStatement : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test preproc statement: ", *pTc);

      size_t pPos;
      pTc-&gt;find("#", pPos);
      if (pPos &lt; pTc-&gt;size())
      {
        doActions(pTc);
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add Semi to scope stack top statements_</span>

  class HandlePreprocStatement : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandlePreprocStatement(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle preproc statement: ", *pTc);

      Lexer::ITokenCollection* pClone = pTc-&gt;clone();
      if (p_Repos-&gt;scopeStack().size() == 0)
        return;
      ASTNode* pElem = p_Repos-&gt;scopeStack().top();
      pElem-&gt;statements_.push_back(pClone);

      GrammarHelper::showParse("Preproc Stmt", *pTc);
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect namespace statements</span>

  class NamespaceDefinition : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test namespace definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("namespace", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add namespace info to scope stack top</span>

  class HandleNamespaceDefinition : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleNamespaceDefinition(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle namespace definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("namespace", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "namespace";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("namespace def", *pTc);
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect class statements</span>

  class ClassDefinition : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test class definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("class", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
        if (tc.contains("interface"))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add class info to scope stack top</span>

  class HandleClassDefinition : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleClassDefinition(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle class definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::priv;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();
      size_t typeIndex;
      pTc-&gt;find("class", typeIndex);
      if (typeIndex &lt; pTc-&gt;size())
      {
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "class";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("class def", *pTc);
      }
      else  <span class="comments">// C#</span>
      {
        pTc-&gt;find("interface", typeIndex);
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "interface";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("interface def", *pTc);
      }
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect struct statements</span>

  class StructDefinition : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test struct definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("struct", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add struct info to scope stack top</span>

  class HandleStructDefinition : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleStructDefinition(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle struct definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::publ;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("struct", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "struct";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      p_Repos-&gt;AST().typeMap()[name] = top;

      GrammarHelper::showParse("struct def", *pTc);
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect C++ function definitions</span>

  class CppFunctionDefinition : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = pRepo-&gt;scopeStack();
      if (stack.size() &lt; 2)
        return IRule::Continue;

      std::string parentType = stack.predOfTop()-&gt;type_;
      if (parentType != "namespace" && parentType != "class" && parentType != "struct")
        return IRule::Continue;

      const Lexer::ITokenCollection& tc = *pTc;

      if (tc[tc.size() - 1] == "{")
      {
        if (GrammarHelper::isFunction(*pTc))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add function info to scope stack top</span>

  class HandleCppFunctionDefinition : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleCppFunctionDefinition(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = p_Repos-&gt;scopeStack();
     
      if (stack.size() == 0)
        return;

      ASTNode* top = stack.top();

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))
      --nameIndex;
      else return;
      std::string name = (*pTc)[nameIndex];

      <span class="comments">// is function a destructor?</span>

      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      {
        --nameIndex;
        name = "~" + name;
      }

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      GrammarHelper::showParse("function def", *pTc);

      <span class="comments">// is function an operator?</span>

      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      {
        name = "operator" + (*pTc)[operIndex + 1];<span class="comments">// +(*pTc)[operIndex + 2];</span>
        if ((*pTc)[operIndex + 2] != "(")
          name += (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }
      <span class="comments">// is function a member of a class or struct?</span>

      if (nameIndex &gt; 1 && (*pTc)[nameIndex - 1] == "::")
      {
        <span class="comments">//----&lt; start find class name &gt;--------------------</span>

        std::string className = (*pTc)[nameIndex - 2];

        <span class="comments">// is class a template?</span>

        if (className == "&gt;")
        {
          size_t startParam = GrammarHelper::findLast(*pTc, "&lt;");
          if (0 &lt; startParam && startParam &lt; pTc-&gt;size())
            className = (*pTc)[startParam - 1];
        }
        <span class="comments">//----&lt; end find class name &gt;----------------------</span>
        <span class="comments">/*
        * - this function's ASTNode is at stack top
        * - find ASTNode of function's class
        * - unlink function ASTNode from stack top predecessor
        * - relink function ASTNode to it's class ASTNode
        * - leave function ASTNode on stack top as it may have child nodes
        */</span>
        ASTNode* pClassNode = p_Repos-&gt;AST().find(className);
        if (pClassNode == nullptr)
          return;
        if (p_Repos-&gt;scopeStack().size() &lt; 2)
          return;

        ASTNode* pFunctNode = p_Repos-&gt;scopeStack().top();
        ASTNode* pParentNode = p_Repos-&gt;scopeStack().predOfTop();
        if(pParentNode-&gt;children_.size() &gt; 0)
          pParentNode-&gt;children_.pop_back();           <span class="comments">// unlink function</span>
        pFunctNode-&gt;parentType_ = pClassNode-&gt;type_;
        pClassNode-&gt;children_.push_back(pFunctNode);   <span class="comments">// relink function</span>
        return;
      }
      <span class="comments">// is this a lambda?</span>

      std::string packageName = p_Repos-&gt;package();
      std::string ext = FileSystem::Path::getExt(packageName);

      size_t posOpenBracket;
      pTc-&gt;find("[", posOpenBracket);
      size_t posCloseBracket;
      pTc-&gt;find("]", posCloseBracket);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posOpenParen;
      pTc-&gt;find("(", posOpenParen);
      if (posCloseBracket != posBrace + 1 && posCloseBracket != posOpenParen + 1) <span class="comments">// []{ or [](</span>
        return;
      if (posOpenBracket &lt; posCloseBracket && posBrace == (posCloseBracket + 1) && posBrace &lt; pTc-&gt;size())
      {
        std::string name;
        for (size_t i = posOpenBracket; i &lt; posBrace; ++i)
          name += (*pTc)[i];
        top-&gt;name_ = name;
        top-&gt;type_ = "lambda";
      }
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect C# function definitions</span>

  class CSharpFunctionDefinition : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# function definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
          se.add(tc[i]);

        if (GrammarHelper::isFunction(se))
        {
          doActions(&se);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add function info to scope stack top</span>

  class HandleCSharpFunctionDefinition : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleCSharpFunctionDefinition(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle C# function definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t nameIndex;
      if (pTc-&gt;find("(", nameIndex))
        --nameIndex;
      else
        return;

      std::string name = (*pTc)[nameIndex];

      <span class="comments">// is function a destructor?</span>

      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      {
        --nameIndex;
        name = "~" + name;
      }

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("function def", *pTc);

      <span class="comments">// is function an operator?</span>

      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      {
        name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }

      <span class="comments">// is lambda?</span>

      size_t posParen;
      pTc-&gt;find("(", posParen);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posEqual;
      pTc-&gt;find("=", posEqual);
      if (posParen &lt; posBrace && posBrace &lt; pTc-&gt;size())
      {
        if (posEqual &lt; pTc-&gt;size() - 1 && (*pTc)[posEqual + 1] == "&gt;")
        {
          std::string name;
          for (size_t i = posParen; i &lt;= posBrace; ++i)
            name += (*pTc)[i];
          top-&gt;name_ = name;
          top-&gt;type_ = "lambda";
        }
      }
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect control definitions</span>

  class ControlDefinition : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test control definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("(", len);
        if (len &lt; tc.size() && GrammarHelper::isControlKeyWord(tc[len - 1]))
        {
          doActions(pTc);
          return IRule::Stop;
        }
        else if (tc.size() &gt; 1 && GrammarHelper::isControlKeyWord(tc[tc.size() - 2]))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add control info to scope stack top</span>

  class HandleControlDefinition : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleControlDefinition(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle control definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top;
      if ((p_Repos-&gt;scopeStack()).size() &gt; 0)
        top = p_Repos-&gt;scopeStack().top();
      else
        return;

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))         <span class="comments">// if, for, while, switch, catch</span>
        --nameIndex;
      <span class="comments">//if (nameIndex == pTc-&gt;size() - 1)     // do, try - they don't have parens</span>
      else
        nameIndex = pTc-&gt;size() - 2;
      std::string name = (*pTc)[nameIndex];
      top-&gt;type_ = "control";
      top-&gt;name_ = name;

      GrammarHelper::showParse("control def", *pTc);
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to send semi-expression that starts a function def</span>
  <span class="comments">// to console</span>

  class PrintFunction : public IAction
  <span class="clsClass">{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrintFunction(Repository* pRepos)
    <span class="funClass">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      std::ostringstream out;
      <span class="comments">//out &lt;&lt; "\n  FuncDef: " &lt;&lt; pTc-&gt;show().c_str();</span>
      Rslt::write(out.str());
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to send signature of a function def to console</span>

  class PrettyPrintFunction : public IAction
  <span class="clsClass">{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrettyPrintFunction(Repository* pRepos) : p_Repos(pRepos) <span class="funClass">{
	}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      size_t len;
      pTc-&gt;find(")", len);

      std::ostringstream out;
      out &lt;&lt; "\n\n  Pretty Stmt:    ";
      for (size_t i = 0; i &lt; len + 1; ++i)
        out &lt;&lt; (*pTc)[i] &lt;&lt; " ";
      out &lt;&lt; "\n";
      Rslt::write(out.str());
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect C++ Declaration</span>
  <span class="comments">/*
  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip off modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</span>
  class CppDeclaration : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ declaration: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      <span class="comments">// begin added 2/26/2017</span>

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPrivate;
      pTc-&gt;find("private", posPrivate);
      if (posPrivate &lt; pTc-&gt;size())
      {
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::priv;
      }

      size_t posProtected;
      pTc-&gt;find("protected", posProtected);
      if (posProtected &lt; pTc-&gt;size())
      {
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::prot;
      }

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      {
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }

      <span class="comments">// end added 2/26/2017</span>

      if (tc.size() &gt; 0 && tc[0] == "using")
      {
        doActions(pTc);
        return IRule::Stop;
      }

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        std::string nextToLast = tc[tc.size() - 2];
        if (nextToLast == "delete" || nextToLast == "default" || nextToLast == "const")
        {
          {
            <span class="comments">// function declaration</span>
            doActions(pTc);
            return IRule::Stop;
          }
        }
        std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;
        
        if (GrammarHelper::isDataDeclaration(tc) || GrammarHelper::isFunctionDeclaration(tc, parentType))
        {
          doActions(pTc);
          return IRule::Stop;
        }

        if (parentType != "function")
        {
          <span class="comments">// can't be executable so must be declaration</span>

          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add declaration info to scope stack top</span>

  class HandleCppDeclaration : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleCppDeclaration(Repository* pRepos) : p_Repos(pRepos) <span class="funClass">{
	}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle C++ declaration: ", *pTc);

      <span class="comments">// save declaration info in ASTNode</span>

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      {
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }

      if (GrammarHelper::isFunctionDeclaration(se,"parentNotFunction"))
      {
        return;
      }

      if (GrammarHelper::isDataDeclaration(se))
      {
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect C# Declaration</span>
  <span class="comments">/*
  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip of modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</span>
  class CSharpDeclaration : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# declaration: ", *pTc);

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      {
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc.size() &gt; 0 && tc[0] == "using")
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }

      Lexer::Semi se;
      se.clone(*pTc);

      if (GrammarHelper::isDataDeclaration(se))
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to add declaration info to scope stack top</span>

  class HandleCSharpDeclaration : public IAction
  <span class="clsClass">{
    Repository* p_Repos;

  public:
    HandleCSharpDeclaration(Repository* pRepos) : p_Repos(pRepos) <span class="funClass">{
	}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle C# declaration: ", *pTc);

      <span class="comments">// store declaration info in ASTNode</span>

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      {
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }

      std::string parentType = p_Repos-&gt;scopeStack().top()-&gt;type_;

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      {
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::functionDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("function declar", *pTc);
      }
      else
      {
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// rule to detect C++ Executable</span>

  class CppExecutable : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ executable: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        <span class="comments">// remove modifiers, comments, newlines, returns, and initializers</span>

        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        {
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          {
            se.add(";");
            break;
          }
          else
            se.add(tc[i]);
        }
        if (se.size() != 3)  <span class="comments">// not a declaration</span>
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
</span>
  <span class="comments">///////////////////////////////////////////////////////////////</span>
  <span class="comments">// action to display C++ executable info</span>

  class HandleCppExecutable : public IAction
  <span class="clsClass">{
    Repository* p_Repo;

  public:
    HandleCppExecutable(Repository* pRepo) : p_Repo(pRepo) <span class="funClass">{
	}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle C++ executable: ", *pTc);

      GrammarHelper::showParse("executable", *pTc);
    }</span>
  };
  <span class="comments">///////////////////////////////////////////////////////////////</span></span>
  <span class="comments">// rule to detect C# Executable</span>

  class CSharpExecutable : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# executable: ", *pTc);

      const Lexer::ITokenCollection& in = *pTc;
      Lexer::Semi tc;
      for (size_t i = 0; i &lt; in.size(); ++i)
        tc.add(in[i]);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        <span class="comments">// remove modifiers, comments, newlines, returns, and initializers</span>

        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        {
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          {
            se.add(";");
            break;
          }
          else
            se.add(tc[i]);
        }
        if (se.size() != 3)  <span class="comments">// not a declaration</span>
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  };
  <span class="comments">///////////////////////////////////////////////////////////////</span></span>
  <span class="comments">// action to display C# executable info</span>

  class HandleCSharpExecutable : public IAction
  <span class="clsClass">{
    Repository* p_Repo;

  public:
    HandleCSharpExecutable(Repository* pRepo) : p_Repo(pRepo) <span class="funClass">{
	}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle C# executable: ", *pTc);

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      GrammarHelper::showParse("executable", se);
    }</span>
  };
  <span class="comments">///////////////////////////////////////////////////////////////</span></span>
  <span class="comments">// default rule</span>
  <span class="comments">// - this is here to catch any Semi that didn't parse</span>
  <span class="comments">// - We don't have rule for enums, so they are caugth here</span>

  class Default : public IRule
  <span class="clsClass">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Test default: ", *pTc);

      doActions(pTc);  <span class="comments">// catches everything</span>
      return IRule::Stop;
    }</span>
  };
  <span class="comments">///////////////////////////////////////////////////////////////</span></span>
  <span class="comments">// action to display default info</span>

  class HandleDefault : public IAction
  <span class="clsClass">{
    Repository* p_Repo;

  public:
    HandleDefault(Repository* pRepo) : p_Repo(pRepo) <span class="funClass">{
	}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="funClass">{
      GrammarHelper::showParseDemo("Handle default: ", *pTc);
      GrammarHelper::showParse("default: ", *pTc);
    }</span>
  };
}</span>
#endif
    </pre>
  </body>
</html>
