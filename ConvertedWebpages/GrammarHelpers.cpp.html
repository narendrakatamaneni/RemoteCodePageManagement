<DOCTYPE !HTML>
<html>
  <head>
    <Title>GrammarHelpers.cpp</Title>
    <style>
      body {
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }
      </style>
  <link rel = "stylesheet" type = "text/css" href = "style.css" >
  <script src="script.js"> </script> 
  </head>

  <body>
 <input type ="submit" value= "Comments" id ="cmt" onclick="togglevisibility('comments')" ></input>
 <input type ="submit" value= "Class"  id ="cls" onclick="togglevisibility('clsClass')" ></input>
 <input type ="submit" value= "Function" id ="fun" onclick="togglevisibility('funClass')" ></input>
    <h3>Dependencies: 
      <a href="GrammarHelpers.h.html">GrammarHelpers.h</a><br/>
      <a href="Semi.h.html">Semi.h</a><br/>
      <a href="Logger.h.html">Logger.h</a><br/>
      <a href="Utilities.h.html">Utilities.h</a><br/>
    </h3>    <pre>
<span class="comments">/////////////////////////////////////////////////////////////////////////</span>
<span class="comments">// GrammarHelpers.cpp - Functions providing base grammatical analyses  //</span>
<span class="comments">// ver 1.4                                                             //</span>
<span class="comments">// Author:      Narendra Katamaneni, Syracuse University,              //</span>
<span class="comments">/////////////////////////////////////////////////////////////////////////</span>

#include "GrammarHelpers.h"
#include "../SemiExpression/Semi.h"
#include "../Logger/Logger.h"
#include "../Utilities/Utilities.h"
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;

using namespace CodeAnalysis;

<span class="comments">//----&lt; is tok a control keyword for either C++ or C# ? &gt;------------</span>

bool GrammarHelper::isControlKeyWord(const std::string& tok)
<span class="funClass">{
  const static size_t numKeys = 9;
  const static std::string keys[numKeys]
    = { "for", "foreach", "do", "while", "switch", "if", "else", "try", "catch" };

  for (int i = 0; i &lt; numKeys; ++i)
  {
    if (tok == keys[i])
      return true;
  }
  return false;
}</span>
<span class="comments">//----&lt; does Semi contain at least one control keyword ? &gt;--------</span>

bool GrammarHelper::hasControlKeyWord(const Lexer::ITokenCollection& se)
<span class="funClass">{
  for (size_t i = 0; i &lt; se.size(); ++i)
  {
    if (GrammarHelper::isControlKeyWord(se[i]))
      return true;
  }
  return false;
}</span>
<span class="comments">//----&lt; is Semi a function defin or declar ? &gt;--------------------</span>

bool GrammarHelper::isFunction(const Lexer::ITokenCollection& se)
<span class="funClass">{
  if (se.last() != "{")
    return false;
  size_t len;
  se.find("(", len);
  if (0 &lt; len && len &lt; se.size() && !isControlKeyWord(se[len - 1]))
  {
    size_t posEquals; 
    se.findLast("=", posEquals);
    if (posEquals &lt; se.size() - 1 && se[posEquals + 1] == "&gt;")
    {
      <span class="comments">// C# lambda</span>
      return false;
    }
    return true;
  }
  if (len == 0)
  {
    size_t posEquals;
    se.find("=", posEquals);
    if (posEquals &lt; se.size() - 1 && se[posEquals + 1] == "&gt;")
    {
      <span class="comments">// C# lambda</span>
      return true;
    }
  }
  return false;
}</span>
<span class="comments">//----&lt; has function and function has at least one argument &gt;--------</span>

bool GrammarHelper::hasArgs(const Lexer::ITokenCollection& se)
<span class="funClass">{
  if (!isFunction(se))
    return false;

  size_t posOpenParen;
  se.find("(", posOpenParen);
  size_t posCloseParen;
  se.find(")", posCloseParen);
  if (posOpenParen &lt; posCloseParen && posCloseParen &lt; se.size())
  {
    if (posCloseParen &gt; posOpenParen + 1)
      return true;
  }
  return false;
}</span>
<span class="comments">//----&lt; is Semi a function defin or declar ? &gt;--------------------</span>

bool GrammarHelper::isFunctionDefinition(const Lexer::ITokenCollection& se)
<span class="funClass">{
  if (se.size() &gt; 0 && se[se.size() - 1] != "{")
    return false;

  if (isFunction(se))
    return true;
  
  return false;
}</span>
<span class="comments">//----&lt; find last matching token in Semi &gt;------------------------</span>

size_t GrammarHelper::findLast(const Lexer::ITokenCollection& se, const std::string& token)
<span class="funClass">{
  size_t endIndex = se.size() - 1;
  for (size_t i = 0; i &lt; se.size(); ++i)
  {
    std::string debugTok = se[endIndex - i];
    if (se[endIndex - i] == token)
      return endIndex - i;
  }
  return se.size();
}</span>
<span class="comments">//----&lt; is tok a type qualifier keyword ? &gt;--------------------------</span>

bool GrammarHelper::isQualifierKeyWord(const std::string& tok)
<span class="funClass">{
  const size_t numKeys = 21;            <span class="comments">// its declar else executable.</span>
  const static std::string keys[numKeys] = {
    "const", "extern", "friend", "mutable", "signed", "static", "abstract", 
    "typedef", "typename", "unsigned", "volatile", "&", "*", <span class="comments">/*"std",*/ /*"::",*/
    "public", "protected", "private", ":", "typename", "typedef", "++", "--"
  };
  for (int i = 0; i &lt; numKeys; ++i)
    if (tok == keys[i])
      return true;
  return false;
}</span>
<span class="comments">//----&lt; strip qualifier keywords from Semi &gt;----------------------</span>

void GrammarHelper::removeQualifiers(Lexer::ITokenCollection& tc)
<span class="funClass">{
  size_t i = 0;
  while (i &lt; tc.size())
  {
    if (isQualifierKeyWord(tc[i]))
      tc.remove(i);
    else
      ++i;
  }
}</span>
<span class="comments">//----&lt; remove calling argument qualifiers after first paren &gt;-------</span>

void GrammarHelper::removeCallingArgQualifiers(Lexer::ITokenCollection& tc)
<span class="funClass">{
  <span class="comments">//std::string debug = tc.show();</span>

  size_t begin;
  tc.find("(", begin);
  size_t end;
  tc.find(")", end);
  if (begin == tc.size() || end == tc.size() || begin &gt;= end)
    return;
  size_t i = begin + 1;
  while (true)
  {
    if (isQualifierKeyWord(tc[i]))
      tc.remove(tc[i]);
    if (tc[i] == ")")
      break;
    ++i;
  }
}</span>
<span class="comments">//----&lt; is token a scope connector ? &gt;-------------------------------</span>

bool isScopeConnector(const std::string& tok)
<span class="funClass">{
  if (tok == "::" || tok == ".")
    return true;
  return false;
}</span>
<span class="comments">//----&lt; is first function argument a declaration ? &gt;-----------------</span>

bool GrammarHelper::isFirstArgDeclaration(const Lexer::ITokenCollection& tc, const std::string& parentType)
<span class="funClass">{
  if(!isFunction(tc))
    return false;  <span class="comments">// not a function</span>

  if (parentType == "function")
    return false;  <span class="comments">// functions don't declare other functions</span>

  Lexer::Semi se;
  se.clone(tc);

  removeCallingArgQualifiers(se);

  size_t posOpenParen;
  se.find("(", posOpenParen);
  size_t posComma;
  se.find(",", posComma);
  size_t posEqual;
  se.find("=", posEqual);
  size_t posCloseParen;
  se.find(")", posCloseParen);
  
  <span class="comments">// must have two adjacent terms without connector, e.g., type and name</span>

  size_t posEnd = (posComma &lt; posEqual) ? posComma : posEqual;
  posEnd = (posEnd &lt; posCloseParen) ? posEnd : posCloseParen;

  <span class="comments">// Note:</span>
  <span class="comments">// - This set of cases works correctly only if name is included in</span>
  <span class="comments">//   declaration, but that is not required by either C++ or C#.</span>
  <span class="comments">// - An example of the problem is X(tok);  If tok is a</span>
  <span class="comments">//   type then this is a constructor function declaration, otherwise</span>
  <span class="comments">//   it is a function invocation with named parameter tok.</span>
  <span class="comments">// - To fix this we would need to know all defined types, both</span>
  <span class="comments">//   those defined by our code and also by all the libraries used.</span>
  <span class="comments">// - for most analysis applications we do not need a completely</span>
  <span class="comments">//   reliable function declaration detector</span>

  size_t numArgTerms = posEnd - posOpenParen - 1;
  switch (numArgTerms)
  {
  case 1:
    <span class="comments">// must be executable</span>
    return false;
    break;
  case 2:
    <span class="comments">// type name</span>
    return true;
    break;
  case 4:
    <span class="comments">// namespace :: type name</span>
    return true;
    break;
  default:
    <span class="comments">// not an argument declaration</span>
    break;
  }
  return false;
}</span>
<span class="comments">//----&lt; is this a function declaration ? &gt;---------------------------</span>

bool GrammarHelper::isFunctionDeclaration(const Lexer::ITokenCollection& tc, const std::string& parentType)
<span class="funClass">{
  <span class="comments">//std::string debug = tc.show();</span>

  if (tc.size() == 0)
    return false;

  if (tc.size() == 1)  <span class="comments">// ; or {</span>
    return false;

  if (tc[tc.size() - 1] != ";")
    return false;

  std::string tok = tc[tc.size() - 2];
  if (tok == "delete" || tok == "default")
    return true;

  if (parentType == "function")
    return false;

  if (!isFunction(tc))
    return false;

  size_t posOper;
  tc.find("operator", posOper);
  if (posOper &lt; tc.size())
    return true;

  Lexer::Semi se;
  se.clone(tc);

  if (isFirstArgDeclaration(se, parentType) || !hasArgs(se))
    return true;

  return false;
}</span>
<span class="comments">//----&lt; is this a function invocation ? &gt;----------------------------</span>
<span class="comments">/*
*  will return false unless invocation uses first paren in Semi
*/</span>
bool GrammarHelper::isFunctionInvocation(const Lexer::ITokenCollection& tc, const std::string& parentType)
<span class="funClass">{
  if (tc.size() == 1)  <span class="comments">// ; or {</span>
    return false;

  if (parentType != "function")
    return false;

  if (isFunction(tc) && !isFunctionDeclaration(tc, parentType) && !isFunctionDefinition(tc))
    return true;
  
  return false;
}</span>
<span class="comments">//----&lt; has function invocation somewhere in expression ? &gt;----------</span>

bool GrammarHelper::hasFunctionInvocation(const Lexer::ITokenCollection& tc, const std::string& parentType)
<span class="funClass">{
  if (tc.size() == 1)  <span class="comments">// ; or {</span>
    return false;

  if (tc.size() &gt; 0 && tc[tc.size() - 1] == "{")
    return false;

  if (parentType != "function")
    return false;

  size_t posParen;
  tc.find("(", posParen);
  Lexer::Semi test;
  test.clone(tc, posParen - 1);
  std::string debug = test.show();
  while (true)
  {
    if (isFunctionInvocation(test, parentType))
      return true;
    test.find("(", posParen, posParen + 1);
    if (posParen == test.size())
      return false;
    Lexer::Semi innerTest;
    innerTest.clone(test, posParen - 1);
    test = innerTest;
    std::string debug = test.show();
  }
  return false;
}</span>
<span class="comments">//----&lt; is this a data declaration ? &gt;-------------------------------</span>

bool GrammarHelper::isDataDeclaration(const Lexer::ITokenCollection& tc)
<span class="funClass">{
  std::string debug3 = tc.show();

  if (tc.size() == 1)  <span class="comments">// ; or {</span>
    return false;

  if (tc.size() &gt; 0 && tc[tc.size() - 1] != ";")
    return false;

  if (tc.size() &gt; 0 && (tc[0] == "~" || tc[0] == "return"))
    return false;

  if(hasControlKeyWord(tc))
    return false;

  size_t insert;
  tc.find("&lt;&lt;", insert);
  size_t extract;
  tc.find("&gt;&gt;", extract);
  if (insert &lt; tc.size() || extract &lt; tc.size())
    return false;

  std::string debug = tc.show();

  Lexer::Semi se;
  se.clone(tc);
  condenseTemplateTypes(se);
  removeQualifiers(se);
  removeCppInitializers(se);
  
  <span class="comments">// is this a function declaration ?</span>

  size_t posParen;
  se.find("(", posParen);
  if (posParen &lt; se.size() && (posParen == 2 || posParen == 3))
    return false;

  removeFunctionArgs(se);
  
  <span class="comments">// is stripped tc of the form "type name ;" or "namespace :: type name ;"</span>

  std::string debug2 = se.show();

  if (se.size() == 3)
    return true;
  if (se.size() == 5 && se[1] == "::")
    return true;

  return false;
}</span>
<span class="comments">//----&lt; is this an executable statement ? &gt;--------------------------</span>

bool GrammarHelper::isExecutable(const Lexer::ITokenCollection& tc, const std::string& parentType)
<span class="funClass">{
  if (tc.size() == 1)  <span class="comments">// ; or {</span>
    return false;

  if (isFunctionDefinition(tc))
    return false;
  if (isFunctionDeclaration(tc, parentType))
    return false;
  if (isDataDeclaration(tc))
    return false;
  return true;
}</span>
<span class="comments">//----&lt; remove initializers from C++ Semi &gt;-----------------------</span>

void GrammarHelper::removeCppInitializers(Lexer::ITokenCollection& tc)
<span class="funClass">{
  std::string debug = tc.show();
  for (size_t i = 0; i &lt; tc.size(); ++i)
  {
    if (tc[i] == "=" || tc[i] == "{")
    {
      size_t j = i;
      while (j &lt; tc.size() && tc[j] != ";")
      {
        tc.remove(j);
      }
      break;
    }
  }
  if (tc.size() &gt; 0 && tc[tc.size() - 1] != ";")
    tc.add(";");
}</span>
<span class="comments">//----&lt; remove initializers from C# Semi &gt;------------------------</span>

void GrammarHelper::removeCSharpInitializers(Lexer::ITokenCollection& tc)
<span class="funClass">{
  std::string debug = tc.show();
  for (size_t i = 0; i &lt; tc.size(); ++i)
  {
    if (tc[i] == "=")
    {
      size_t j = i;
      while (j &lt; tc.size() && tc[j] != ";")
      {
        tc.remove(j);
      }
      break;
    }
  }
  if (tc.size() &gt; 0 && tc[tc.size() - 1] != ";")
    tc.add(";");
}</span>
<span class="comments">//----&lt; remove comments from Semi &gt;-------------------------------</span>

void GrammarHelper::removeComments(Lexer::ITokenCollection& tc)
<span class="funClass">{
  size_t i = 0;
  while (true)
  {
    if (tc.isComment(tc[i]))
      tc.remove(i);
    if (++i == tc.size())
      break;
  }
}</span>
<span class="comments">//----&lt; condense template spec to single token &gt;---------------------</span>

void GrammarHelper::condenseTemplateTypes(Lexer::ITokenCollection& tc)
<span class="funClass">{
  size_t start;
  tc.find("&lt;", start);
  size_t end;
  tc.find("&gt;", end);
  if (start &gt;= end || start == 0)
    return;
  else
  {
    if (end == tc.size())
      tc.find("&gt;::", end);
    if (end == tc.size())
      return;
  }
  std::string save = tc[end];
  std::string tok = tc[start - 1];
  for (size_t i = start; i &lt; end + 1; ++i)
  {
    tok += tc[i];
    if (tc[i] == "typename" || tc[i] == "class")
      tok += " ";
  }
  for (size_t i = start; i &lt; end + 1; ++i)
    tc.remove(start);
  if (save == "&gt;::")
  {
    tok += tc[start + 1];
    tc.remove(start);
  }
  tc[start - 1] = tok;
  <span class="comments">//std::cout &lt;&lt; "\n  -- " &lt;&lt; tc.show();</span>
}</span>
<span class="comments">//----&lt; remove function's formal arguments &gt;-------------------------</span>

void GrammarHelper::removeFunctionArgs(Lexer::ITokenCollection& tc)
<span class="funClass">{
  std::string debug = tc.show();

  size_t start;
  tc.find("(", start);
  size_t end;
  tc.find(")", end);
  if (start &gt;= end || end == tc.size() || start == 0)
    return;
  if (GrammarHelper::isControlKeyWord(tc[start - 1]))
    return;
  for (size_t i = start; i &lt; end + 1; ++i)
    tc.remove(start);
  <span class="comments">//std::cout &lt;&lt; "\n  -- " &lt;&lt; tc.show();</span>
}</span>
<span class="comments">//----&lt; show Semi with Dbug logger &gt;------------------------------</span>

void GrammarHelper::showParse(const std::string& msg, const Lexer::ITokenCollection& se, bool isResult)
<span class="funClass">{
  using Rslt = Logging::StaticLogger&lt;0&gt;;
  using Dbug = Logging::StaticLogger&lt;2&gt;;
  if (Dbug::running() || Rslt::running())
  {
    std::ostringstream out;
    <span class="comments">//out &lt;&lt; "\n  " &lt;&lt; std::left &lt;&lt; std::setw(15) &lt;&lt; msg &lt;&lt; ": ";</span>
    std::string temp = se.show();
    <span class="comments">//if (temp.size() &gt; 80)</span>
    <span class="comments">//  out &lt;&lt; "\n    ";</span>
    <span class="comments">//out &lt;&lt; temp;</span>
	if (isResult && Rslt::running()) {
		<span class="comments">//Rslt::write(out.str());</span>
	}
	else if (Dbug::running()) {
		<span class="comments">//Dbug::write(out.str());</span>
	}
  }
}</span>

void GrammarHelper::showParseDemo(const std::string& msg, const Lexer::ITokenCollection& se)
<span class="funClass">{
  using Demo = Logging::StaticLogger&lt;1&gt;;
  if (Demo::running())
  {
    std::ostringstream out;
    <span class="comments">//out &lt;&lt; "\n  " &lt;&lt; std::left &lt;&lt; std::setw(32) &lt;&lt; msg &lt;&lt; ": ";</span>
    std::string temp = se.show();
	if (temp.size() &gt; 80) {
		<span class="comments">//out &lt;&lt; "\n    ";</span>
	}
    <span class="comments">//out &lt;&lt; temp;</span>
    <span class="comments">//Demo::write(out.str());</span>
  }
}</span>

#ifdef TEST_GRAMMARHELPERS

#include &lt;vector&gt;
#include &lt;iostream&gt;
#include "../SemiExpression/Semi.h"
#include "../Utilities/Utilities.h"

using namespace Lexer;
using Token = std::string;
using Toks = std::vector&lt;Token&gt;;

void load(const Toks& toks, Semi& se)
<span class="funClass">{
  se.clear();
  for (auto item : toks)
    se.add(item);
}</span>

std::string showQualifiers(const Semi& se)
<span class="funClass">{
  std::string temp;
  for (size_t i = 0; i &lt; se.size(); ++i)
    if (GrammarHelper::isQualifierKeyWord(se[i]))
      temp += se[i] + " ";
  return temp;
}</span>

void showPredicate(bool predicate, const std::string& msg)
<span class="funClass">{
  if (predicate)
    std::cout &lt;&lt; "\n    " &lt;&lt; msg;
  else
    std::cout &lt;&lt; "\n    not " &lt;&lt; msg;
}</span>

std::string show(const ITokenCollection& se)
<span class="funClass">{
  std::string temp;
  for (size_t i = 0; i &lt; se.size(); ++i)
    temp += se[i] + " ";
  return temp;
}</span>

void testHelpers(const Semi& seIn)
<span class="funClass">{
  Lexer::Semi se;
  se.clone(seIn);

  CoreUtilities::StringHelper::title("Testing GrammarHelpers");
  std::cout &lt;&lt; "\n  " &lt;&lt; show(se);
  se.trim();
  std::cout &lt;&lt; "\n    removing comments:  " &lt;&lt; show(se);
  std::cout &lt;&lt; "\n    index of last \"(\" is " &lt;&lt; GrammarHelper::findLast(seIn, "(");
  std::cout &lt;&lt; "\n    qualifier keywords are: " &lt;&lt; showQualifiers(seIn);

  std::string debug = se.show();
  showPredicate(GrammarHelper::isFunctionDefinition(se), "function definition");

  std::string parentType = "function";
  std::cout &lt;&lt; "\n  parent type = " &lt;&lt; parentType;
  showPredicate(GrammarHelper::isFunctionDeclaration(se, parentType), "function declaration");
  showPredicate(GrammarHelper::isFunctionInvocation(se, parentType), "function invocation");
  showPredicate(GrammarHelper::hasFunctionInvocation(se, parentType), "has function invocation");
  parentType = "class";
  std::cout &lt;&lt; "\n  parent type = " &lt;&lt; parentType;
  showPredicate(GrammarHelper::isFunctionDeclaration(se, parentType), "function declaration");
  showPredicate(GrammarHelper::isFunctionInvocation(se, parentType), "function invocation");
  showPredicate(GrammarHelper::hasFunctionInvocation(se, parentType), "has function invocation");

  showPredicate(GrammarHelper::isDataDeclaration(se), "data declaration");
  showPredicate(GrammarHelper::hasControlKeyWord(se), "found control Keyword");

  Semi testSE;
  testSE.clone(seIn);
  GrammarHelper::condenseTemplateTypes(testSE);
  std::cout &lt;&lt; "\n    condensing template types: " &lt;&lt; show(testSE);

  testSE.clone(seIn);
  GrammarHelper::removeQualifiers(testSE);
  std::cout &lt;&lt; "\n    removing qualifiers: " &lt;&lt; show(testSE);

  testSE.clone(seIn);
  GrammarHelper::removeCppInitializers(testSE);
  std::cout &lt;&lt; "\n    removing C++ initializers: " &lt;&lt; show(testSE);

  testSE.clone(seIn);
  GrammarHelper::removeFunctionArgs(testSE);
  std::cout &lt;&lt; "\n    removing function args: " &lt;&lt; show(testSE);

  testSE.clone(seIn);
  GrammarHelper::removeCallingArgQualifiers(testSE);
  std::cout &lt;&lt; "\n    removing qualifiers in function calling sequence: " &lt;&lt; show(testSE);
  std::cout &lt;&lt; "\n";
} </span>
int main()
<span class="funClass">{
  CoreUtilities::StringHelper::Title("Testing Grammar Functions");
  std::cout &lt;&lt; "\n  Note:";
  std::cout &lt;&lt; "\n  - Test functions are applied to Semis that they should change and those they should not.";
  std::cout &lt;&lt; "\n  - The intent is to make sure they do what they are supposed to do without harming Semis";
  std::cout &lt;&lt; "\n  - that should not change.\n";

  Toks tokset0 = { "<span class="comments">/* Test0 */", ";" };
  Toks tokset1 = { "<span class="comments">/* Test1 */", "extern", "int", "x", "[", "2", "]", "=", "{", "1", ",", "2", "}", ";" };
  Toks tokset2 = { "<span class="comments">/* Test2 */", "extern", "int", "x", "[", "2", "]", "{", "1", ",", "2", "}", ";" };
  Toks tokset3 = { "<span class="comments">/* Test3 */", "if", "(", "x", "==", "y", ")", "doThing", "(", "3", ")", ";" };
  Toks tokset4 = { "<span class="comments">/* Test4 */", "void", "fun", "(", "int", "anInteger", ")", "{" };
  Toks tokset5 = { "<span class="comments">/* Test5 */", "void", "fun", "(", "int", "anInteger", ")", ";" };
  Toks tokset6 = { "<span class="comments">/* Test6 */", "int", "fun", "(", "const", "int", "&", "anItegerRef", ")", ";" };
  Toks tokset7 = { "<span class="comments">/* Test7 */", "template", "&lt;", "typename", "C", "&gt;", "class", "A", "{" };
  Toks tokset8 = { "<span class="comments">/* Test7 */", "template", "&lt;", "typename", "C", "&gt;", "void", "fun", "(", "const", "C", "&", "c", ")", "{" };
  Toks tokset9 = { "<span class="comments">/* Test9 */", "std", "::","vector", "&lt;", "std", "::", "string", "&gt;", "aVec", ";" };
  Toks tokset10 = { "<span class="comments">/* Test10 */", "ClassName", "(", ")", ";" };
  Toks tokset11 = { "<span class="comments">/* Test11 */", "~", "ClassName", "(", ")", ";" };
  Toks tokset12 = { "<span class="comments">/* Test12 */", "ClassName", "(", "int", "count", ")", ";" };
  Toks tokset13 = { "<span class="comments">/* Test13 */", "ClassName", "(", "int", "count", ")", ":", "count_", "(", "count", ")", "{" };
  Toks tokset14 = { "<span class="comments">/* Test14 */", "Lexer", "::", "Semi", "se", "(", "nullPtr", ")", ";" };
  Toks tokset15 = { "<span class="comments">/* Test15 */", "public", "abstract", "void", "doAction", "(", "CSemi", ".", "CSemi", "semi", ")", ";" };

  Lexer::Semi se;

  load(tokset0, se);
  testHelpers(se);
  load(tokset1, se);
  testHelpers(se);
  load(tokset2, se);
  testHelpers(se);
  load(tokset3, se);
  testHelpers(se);
  load(tokset4, se);
  testHelpers(se);
  load(tokset5, se);
  testHelpers(se);
  load(tokset6, se);
  testHelpers(se);
  load(tokset7, se);
  testHelpers(se);
  load(tokset8, se);
  testHelpers(se);
  load(tokset9, se);
  testHelpers(se);
  load(tokset10, se);
  testHelpers(se);
  load(tokset11, se);
  testHelpers(se);
  load(tokset12, se);
  testHelpers(se);
  load(tokset13, se);
  testHelpers(se);
  load(tokset14, se);
  testHelpers(se);
  load(tokset15, se);
  testHelpers(se);
}</span>
#endif


    </pre>
  </body>
</html>
