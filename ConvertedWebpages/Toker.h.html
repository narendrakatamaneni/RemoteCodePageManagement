<DOCTYPE !HTML>
<html>
  <head>
    <Title>Toker.h</Title>
    <style>
      body {
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }
      </style>
  <link rel = "stylesheet" type = "text/css" href = "style.css" >
  <script src="script.js"> </script> 
  </head>

  <body>
 <input type ="submit" value= "Comments" id ="cmt" onclick="togglevisibility('comments')" ></input>
 <input type ="submit" value= "Class"  id ="cls" onclick="togglevisibility('clsClass')" ></input>
 <input type ="submit" value= "Function" id ="fun" onclick="togglevisibility('funClass')" ></input>
    <pre>
#ifndef TOKER_H
#define TOKER_H
<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">// Toker.h - Collects words from a stream                          //</span>
<span class="comments">// ver 1.0                                                         //</span>
<span class="comments">// Jim Fawcett, Syracuse University						   //</span>
<span class="comments">/////////////////////////////////////////////////////////////////////</span>
<span class="comments">/*
 * Package Operations:
 * -------------------
 * This tokenizer is implemented with the State Pattern, and:
 * - Collects words, called tokens, from a stream.
 * - Discards all whitespace except for newlines which are returned as
 *   single character tokens.
 * - By default, collects and discards all comments, but has an option
 *   to return each comment as a single token.
 * - Also returns quoted strings and quoted characters as tokens.
 *   Toker correctly handles the C# string @"...".
 * - This package demonstrates how to build a tokenizer based on the
 *   State Pattern.
  *
 * Required Files:
 * ---------------
 * Toker.h, Toker.cpp
 *
 * Maintenance History
 * -------------------
 * ver 1.1 : 27 Feb 2019
 * - fixed bugs in toker by checking for end-of-file in getTok() function
 *   in SingleLineCommentState and MultiLineCommentState
 * ver 1.0 : 09 Feb 2019
 * - first release - port of C# design
 */</span>

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;deque&gt;
#include &lt;unordered_set&gt;
#include &lt;cctype&gt;
#include &lt;locale&gt;
#include "../CppProperties/Properties.h"

using namespace Utilities;
using Token = std::string;

namespace Lexer
{
	const std::locale loc;

	<span class="comments">///////////////////////////////////////////////////////////////////</span>
	<span class="comments">// ITokenSource interface</span>
	<span class="comments">// - Declares operations expected of any source of tokens</span>
	<span class="comments">// - Typically we would use either files or strings.  This demo</span>
	<span class="comments">//   provides a source only for Files, e.g., TokenFileSource, below.</span>

	struct ITokenSource
	{
		virtual ~ITokenSource() <span class="funClass">{
		}</span>
		virtual bool open(std::string path) = 0;
		virtual void close() = 0;
		virtual int next() = 0;
		virtual int peek(size_t n = 0) = 0;
		virtual bool end() = 0;
		Property&lt;size_t&gt; lineCount;
	};

	<span class="comments">///////////////////////////////////////////////////////////////////</span>
	<span class="comments">// ITokenState interface</span>
	<span class="comments">// - Declares operations expected of any token gathering state</span>

	class TokenSourceFile;
	struct TokenContext;

	class ITokenState
	<span class="clsClass">{
	public:
		virtual ~ITokenState() <span class="funClass">{
		}</span>
		static void setContext(TokenContext* pContext);
		virtual Token getTok() = 0;
		virtual bool isWhiteSpace() = 0;
		virtual bool isPunctuation() = 0;
		virtual bool isDone() = 0;
		virtual ITokenState* nextState() = 0;
		Property&lt;std::unordered_set&lt;std::string&gt;&gt; oneCharTokens_;
		Property&lt;std::unordered_set&lt;std::string&gt;&gt; twoCharTokens_;

	protected:
		static TokenContext* pContext_;  <span class="comments">// derived classes store context ref here</span>
		TokenSourceFile* pSrc_ = nullptr;
	};
</span>
	<span class="comments">///////////////////////////////////////////////////////////////////</span>
	<span class="comments">// TokenContext class</span>
	<span class="comments">// - holds all the tokenizer states</span>
	<span class="comments">// - holds source of tokens</span>

	struct TokenContext
	{
		ITokenState* pCurrentState_ = nullptr;
		ITokenState* pWhiteSpaceState_ = nullptr;
		ITokenState* pAlphNumState_ = nullptr;
		ITokenState* pPunctuationState_ = nullptr;
		ITokenState* pNewLineState_ = nullptr;
		ITokenState* pSingleLineCommentState_ = nullptr;
		ITokenState* pMultiLineCommentState_ = nullptr;
		ITokenState* pSingleQuoteState_ = nullptr;
		ITokenState* pDoubleQuoteState_ = nullptr;
		ITokenSource* pSrc_ = nullptr;

		TokenContext();
		~TokenContext();
		TokenContext(const TokenContext&) = delete;
		TokenContext& operator=(const TokenContext&) = delete;
	};

	<span class="comments">///////////////////////////////////////////////////////////////////</span>
	<span class="comments">// TokenSourceFile class</span>
	<span class="comments">// - extracts integers from token source</span>
	<span class="comments">// - Streams often use terminators that can't be represented by</span>
	<span class="comments">//   a character, so we collect all elements as ints</span>
	<span class="comments">// - keeps track of the line number where a token is found</span>
	<span class="comments">// - uses StreamReader which correctly handles byte order mark</span>
	<span class="comments">//   characters and alternate text encodings.</span>

	class TokenSourceFile : public ITokenSource
	<span class="clsClass">{
	private:
		std::ifstream fs_;            <span class="comments">// physical source of text</span>
		std::deque&lt;int&gt; charQ_;       <span class="comments">// enqueing ints but using as chars</span>
		TokenContext* pContext_;

	public:
		TokenSourceFile(TokenContext* pContext);
		~TokenSourceFile();
		bool open(std::string path);
		void close();
		int next();
		int peek(size_t n = 0);  <span class="comments">// peek n ints into source without extracting them</span>
		bool end();
	};
</span>
	<span class="comments">///////////////////////////////////////////////////////////////////</span>
	<span class="comments">// TokenState class</span>
	<span class="comments">// - base for all the tokenizer states</span>

	class TokenState : public ITokenState
	<span class="clsClass">{
	public:
		TokenState(const TokenState&) = delete;
		TokenState& operator=(const TokenState&) = delete;
		virtual ~TokenState() <span class="funClass">{
		}</span>

		TokenState();
		static void setContext(TokenContext* pContext);
		std::unordered_set&lt;std::string&gt;& oneCharTokens();
		bool oneCharTokensContains(const std::string& tok);
		std::unordered_set&lt;std::string&gt;& twoCharTokens();
		bool twoCharTokensContains(const std::string& tok);
		bool addOneCharToken(const std::string& oneCharTok);
		bool removeOneCharToken(const std::string& oneCharTok);
		bool addTwoCharToken(const std::string& twoCharTok);
		bool removeTwoCharToken(const std::string& twoCharTok);
		bool open(const std::string& path);

		virtual Token getTok() = 0;

		bool isWhiteSpace();
		bool isNewLine();
		bool isAlphaNum();
		bool isSingleLineComment();
		bool isMultiLineComment();
		bool isDoubleQuote();
		bool isSingleQuote();
		bool isPunctuation();
		ITokenState* nextState();
		bool isDone();
		bool isEscaped(Token tok);
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// Derived State Classes      getTok() returns</span>
	<span class="comments">// -------------------------  -------------------------------------</span>
	<span class="comments">/* - WhiteSpaceState          Token with space, tab, and return chars
	 * - NewLineState             Token with newline
	 * - AlphaNumState            Token with letters, digits, and underscore
	 * - SingleLineCommentState   Token holding C++ style comment
	 * - MultiLineCommentState    Token holding C style comment
	 * - SingleQuoteState         Token holding a quoted character
	 * - DoubleQuoteState         Token holding a quoted string
	 * - PunctuationState         Token holding anything not included above
	 * ----------------------------------------------------------------
	 * - Each state class accepts a reference to the context in its
	 *   constructor and saves in its inherited context_ property.
	 * - It is only required to provide a getTok() method which
	 *   returns a token conforming to its state, e.g., whitespace, ...
	 * - getTok() assumes that the TokenSource's first character
	 *   matches its type e.g., whitespace char, ...
	 * - The nextState() method ensures that the condition, above, is
	 *   satisfied.
	 * - The getTok() method promises not to extract characters from
	 *   the TokenSource that belong to another state.
	 * - These requirements lead us to depend heavily on peeking into
	 *   the TokenSource's content.
	 */</span>
	 <span class="comments">///////////////////////////////////////////////////////////////////</span>
	 <span class="comments">// WhiteSpaceState class</span>
	 <span class="comments">// - extracts, from context_.src, contiguous whitespace chars as token</span>
	 <span class="comments">// - will be thrown away by tokenizer</span>

	class WhiteSpaceState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get non-whitespace &gt;---------------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();     <span class="comments">// first is WhiteSpace</span>

			while (pContext_-&gt;pCurrentState_-&gt;isWhiteSpace())  <span class="comments">// stop when non-WhiteSpace</span>
			{
				tok += (char)pContext_-&gt;pSrc_-&gt;next();
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// NewLineState class</span>
	<span class="comments">// - extracts, from context_.src, a single newline character</span>

	class NewLineState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; return first char in src, as it must be a newline &gt;------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();     <span class="comments">// first is newline</span>

			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// AlphaNumState class</span>
	<span class="comments">// - extracts contiguous letter and digit chars as a token</span>

	class AlphaNumState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get non-alphanum &gt;-----------------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();  <span class="comments">// first is alphanum</span>

			while (isAlphaNum())            <span class="comments">// stop when non-alphanum</span>
			{
				tok += (char)pContext_-&gt;pSrc_-&gt;next();
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// SingleLineCommentState class</span>
	<span class="comments">// - extracts single line comment as a token</span>

	class SingleLineCommentState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get newline &gt;--------------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();   <span class="comments">// char is /</span>
			tok += (char)pContext_-&gt;pSrc_-&gt;next();   <span class="comments">// char is /</span>

			char ch;
			while (true)   <span class="comments">// stop when newline</span>
			{
				ch = (char)pContext_-&gt;pSrc_-&gt;peek();
				if (ch == '\n' || int(ch) == -1)
					break;
				tok += (char)pContext_-&gt;pSrc_-&gt;next();
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// MulitpleLineComment class</span>
	<span class="comments">// - extracts multiple line comment as a token</span>

	class MultiLineCommentState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get comment termintor &gt;------------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();       <span class="comments">// char is /</span>
			tok += (char)pContext_-&gt;pSrc_-&gt;next();       <span class="comments">// char is *</span>

			char ch = ' ', prevCh = ' ';
			while (true)   <span class="comments">// stop when newline</span>
			{
				prevCh = ch;
				ch = (char)pContext_-&gt;pSrc_-&gt;next();
				tok += ch;
				if (prevCh == '*' && ch == '/' || int(ch) == -1)
					break;
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// SingleQuoteState class</span>
	<span class="comments">// - extracts single quoted char as a token with quotes</span>

	class SingleQuoteState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get end quote &gt;--------------------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();       <span class="comments">// char is '\''</span>

			while (true)
			{
				char ch = (char)pContext_-&gt;pSrc_-&gt;next();
				tok += ch;
				if (ch == '\'' && !isEscaped(tok))
					break;
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// DoubleQuoteState class</span>
	<span class="comments">// - extracts text in quotes as a token</span>

	class DoubleQuoteState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get end quote &gt;--------------------</span>

		virtual Token getTok() override
		<span class="funClass">{
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();       <span class="comments">// char is "\"" or "@"</span>
			char nxt = (char)pContext_-&gt;pSrc_-&gt;peek();
			if (nxt == '\"' && tok[0] == '@')
				tok += (char)pContext_-&gt;pSrc_-&gt;next();

			while (true)
			{
				char ch = (char)pContext_-&gt;pSrc_-&gt;next();
				tok += ch;
				if (ch == '\"' && (!isEscaped(tok) || tok[0] == '@'))
					break;
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// PunctuationState class</span>
	<span class="comments">// - extracts contiguous punctuation chars as a token</span>

	class PunctuationState : public TokenState
	<span class="clsClass">{
	public:
		<span class="comments">//----&lt; keep extracting until get non-punctuator &gt;---------------</span>
		<span class="comments">/*
		 * Here is where we handle single char and two char special tokens
		 * as well as other punctuators.
		 */</span>
		virtual Token getTok() override
		<span class="funClass">{
			<span class="comments">// is this a two char special token?</span>
			Token test;
			test += (char)pContext_-&gt;pSrc_-&gt;peek();
			test += (char)pContext_-&gt;pSrc_-&gt;peek(1);
			if (twoCharTokensContains(test))
			{
				pContext_-&gt;pSrc_-&gt;next();  <span class="comments">// pop peeked char</span>
				pContext_-&gt;pSrc_-&gt;next();  <span class="comments">// pop peeked char</span>
				return test;
			}
			<span class="comments">// is this a single char special token?</span>
			Token tok;
			tok += (char)pContext_-&gt;pSrc_-&gt;next();       <span class="comments">// pop first punctuator</span>
			if (oneCharTokensContains(tok))
				return tok;

			<span class="comments">// not special token, so continue collecting punctuation chars</span>
			while (pContext_-&gt;pCurrentState_-&gt;isPunctuation())
			{
				<span class="comments">// check for other special cases starting in middle of punctuator</span>
				if (
					isMultiLineComment() || isSingleLineComment() ||
					isDoubleQuote() || isSingleQuote()
					)
					break;
				tok += (char)pContext_-&gt;pSrc_-&gt;next();
			}
			return tok;
		}</span>
	};
	<span class="comments">///////////////////////////////////////////////////////////////////</span></span>
	<span class="comments">// Toker class</span>
	<span class="comments">// - applications need to use only this class to collect tokens</span>

	class Toker
	<span class="clsClass">{
	private:
		TokenContext* pContext_ = nullptr;   <span class="comments">// holds single instance of all states and token source</span>

	public:
		Property&lt;bool&gt; doReturnComments;

		Toker();
		~Toker();
		bool open(const std::string& path);
		void close();
		bool overwrite(Token tok);
		Token getTok();
		bool isDone();
		int lineCount();
		Property&lt;std::unordered_set&lt;std::string&gt;&gt;& oneCharTokens();
		Property&lt;std::unordered_set&lt;std::string&gt;&gt;& twoCharTokens();
		bool addOneCharToken(const std::string& oneCharTok);
		bool removeOneCharToken(const std::string& oneCharTok);
		bool addTwoCharToken(const std::string& twoCharTok);
		bool removeTwoCharToken(const std::string& twoCharTok);
		static bool isWhiteSpace(Token tok);
		static bool isNewLine(Token tok);
		static bool isAlphaNum(Token tok);
		static bool isPunctuator(Token tok);
		static bool isSingleLineComment(Token tok);
		static bool isMultipleLineComment(Token tok);
		static bool isDoubleQuote(Token tok);
		static bool isSingleQuote(Token tok);
	};
}</span>
#endif
    </pre>
  </body>
</html>
