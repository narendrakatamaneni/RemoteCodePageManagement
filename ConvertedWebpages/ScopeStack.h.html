<DOCTYPE !HTML>
<html>
  <head>
    <Title>ScopeStack.h</Title>
    <style>
      body {
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }
      </style>
  <link rel = "stylesheet" type = "text/css" href = "style.css" >
  <script src="script.js"> </script> 
  </head>

  <body>
 <input type ="submit" value= "Comments" id ="cmt" onclick="togglevisibility('comments')" ></input>
 <input type ="submit" value= "Class"  id ="cls" onclick="togglevisibility('clsClass')" ></input>
 <input type ="submit" value= "Function" id ="fun" onclick="togglevisibility('funClass')" ></input>
    <h3>Dependencies: 
      <a href="Logger.h.html">Logger.h</a><br/>
      <a href="Utilities.h.html">Utilities.h</a><br/>
    </h3>    <pre>
#ifndef SCOPESTACK_H
#define SCOPESTACK_H
<span class="comments">/////////////////////////////////////////////////////////////////////////////</span>
<span class="comments">// ScopeStack.h - implements template stack holding specified element type //</span>
<span class="comments">// ver 1.0                                                                 //</span>
<span class="comments">// Author:        Narendra Katamaneni, Syracuse University				   //</span>
<span class="comments">/////////////////////////////////////////////////////////////////////////////</span>
<span class="comments">/*
  Package Operations:
  ===================
  This package contains one class: ScopeStack&lt;element&gt;.  The element type
  is an application specific type designed to hold whatever information you
  need to stack.

  Throws std::exception if stack is popped or peeked when empty.

  Public Interface:
  =================
  ScopeStack&lt;element&gt; stack;
  <span class="comments">// define some element type</span>
  element elem;
  stack.push(elem);
  element popped = stack.pop();

  Required Files:
  ===============


  Build Command:
  ==============
  devenv ScopeStack.sln /rebuild debug

  Maintenance History:
  ====================
  ver 1.0 : 28 Feb 2019
  - first release
*/</span>
#include &lt;list&gt;
#include "../Logger/Logger.h"
#include "../Utilities/Utilities.h"

<span class="comments">// element is a application specific type.  It must provide a function:</span>
<span class="comments">// std::string show() that returns a string display of its parts. see</span>
<span class="comments">// test stub for an example.</span>

namespace CodeAnalysis
{
  template&lt;typename element&gt;
  class ScopeStack <span class="clsClass">{
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;    <span class="comments">// show program results</span>
    using Demo = Logging::StaticLogger&lt;1&gt;;    <span class="comments">// show demonstration outputs</span>
    using Dbug = Logging::StaticLogger&lt;2&gt;;    <span class="comments">// show debugging outputs</span>
    typename typedef std::list&lt;element&gt;::iterator iterator;

    ScopeStack();
    void push(const element& item);
    element pop();
    element& top();
    element& predOfTop();
    size_t size();
    iterator begin();
    iterator end();
  private:
    std::list&lt;element&gt; stack;
    element dbElement;
  };
</span>
  template&lt;typename element&gt;
  ScopeStack&lt;element&gt;::ScopeStack() <span class="funClass">{
  }</span>

  template&lt;typename element&gt;
  typename inline size_t ScopeStack&lt;element&gt;::size() { return stack.size(); }</span>

  template&lt;typename element&gt;
  typename inline ScopeStack&lt;element&gt;::iterator ScopeStack&lt;element&gt;::begin() { return stack.begin(); }</span>

  template&lt;typename element&gt;
  typename inline ScopeStack&lt;element&gt;::iterator ScopeStack&lt;element&gt;::end() { return stack.end(); }</span>

  template&lt;typename element&gt;
  void ScopeStack&lt;element&gt;::push(const element& item)
  <span class="funClass">{
    Demo::flush();
    stack.push_back(item);
    <span class="comments">//Dbug::write("\n--- stack size = " + CoreUtilities::Converter&lt;size_t&gt;::toString(size()) + " ---");</span>
    Dbug::flush();
  }</span>

  template&lt;typename element&gt;
  element ScopeStack&lt;element&gt;::pop()
  <span class="funClass">{
    if (stack.size() == 0)
    {
      throw std::exception("-- attempting to pop empty stack --");
    }
    element item = stack.back();
    stack.pop_back();    
    <span class="comments">//Dbug::write("\n--- stack size = " + CoreUtilities::Converter&lt;size_t&gt;::toString(size()) + " ---");</span>
    Dbug::flush();

    return item;
  }</span>

  template&lt;typename element&gt;
  element& ScopeStack&lt;element&gt;::top()
  <span class="funClass">{
    if (stack.size() == 0)
    {
      throw std::exception("-- attempting to peek top on empty stack --");
    }
    return stack.back();
  }</span>

  template&lt;typename element&gt;
  element& ScopeStack&lt;element&gt;::predOfTop()
  <span class="funClass">{
    if (size() &lt; 2)
    {
      throw std::exception("-- predOfTop() called on stack with less than two elements --");
    }
    iterator iter = --(--end());
    return *iter;
  }</span>

  template&lt;typename element&gt;
  void showStack(ScopeStack&lt;element&gt;& stack, bool indent = true)
  <span class="funClass">{
    if (stack.size() == 0)
    {
      <span class="comments">//std::cout &lt;&lt; "\n  ScopeStack is empty";</span>
      return;
    }
  typename ScopeStack&lt;element&gt;::iterator iter = stack.begin();
    while (iter != stack.end())
    {
      std::string strIndent = std::string(2 * stack.size(), ' ');
      if (!indent)
        strIndent = "";
      element temp = *iter;
      <span class="comments">//std::cout &lt;&lt; "\n  " &lt;&lt; strIndent &lt;&lt; temp-&gt;show();</span>
      ++iter;
    }
  }</span>

  template&lt;typename element&gt;
  void showStack(ScopeStack&lt;element*&gt;& stack, bool indent = true)
  <span class="funClass">{
    if (stack.size() == 0)
    {
      <span class="comments">//std::cout &lt;&lt; "\n  ScopeStack is empty";</span>
      return;
    }
    typename ScopeStack&lt;element*&gt;::iterator iter = stack.begin();
    while (iter != stack.end())
    {
      std::string strIndent = std::string(2 * stack.size(), ' ');
      if (!indent)
        strIndent = "";
      <span class="comments">//std::cout &lt;&lt; "\n  " &lt;&lt; strIndent &lt;&lt; ((*iter)-&gt;show());</span>
      ++iter;
    }
  }</span>
  <span class="comments">//----&lt; walk tree of element nodes &gt;---------------------------------</span>

  template&lt;typename element&gt;
  void TreeWalk(element* pItem, bool details = false)
  <span class="funClass">{
    static std::string path;
    static size_t indentLevel = 0;
    std::ostringstream out;
    <span class="comments">//out &lt;&lt; "\n  " &lt;&lt; std::string(2 * indentLevel, ' ') &lt;&lt; pItem-&gt;show();</span>
	<span class="comments">//std::cout &lt;&lt; out.str();</span>
    auto iter = pItem-&gt;children_.begin();
    ++indentLevel;
    while (iter != pItem-&gt;children_.end())
    {
      TreeWalk(*iter);
	  <span class="comments">//out &lt;&lt; "\n  " &lt;&lt; std::string(2 * indentLevel, ' ') &lt;&lt; pItem-&gt;show();</span>
      ++iter;
    }

    --indentLevel;
  }</span>
}
#endif
    </pre>
  </body>
</html>
